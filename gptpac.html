<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ランダムパックマン</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #000;
      touch-action: none;
    }
    canvas {
      background: #000;
      border: 4px solid #222;
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game" tabindex="0"></canvas>
<script>
// -------- サイズ定義 --------
const COLS=28, ROWS=31, CELL=20, W=COLS*CELL, H=ROWS*CELL;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = W;
canvas.height = H;

// -------- スケーリング調整 --------
function resizeCanvas() {
  const scaleX = window.innerWidth / W;
  const scaleY = window.innerHeight / H;
  const scale = Math.min(scaleX, scaleY);
  canvas.style.width = `${W * scale}px`;
  canvas.style.height = `${H * scale}px`;
  ctx.setTransform(scale, 0, 0, scale, 0, 0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// -------- 定数とユーティリティ --------
const DIR = {
  NONE:{x:0,y:0}, LEFT:{x:-1,y:0}, UP:{x:0,y:-1},
  RIGHT:{x:1,y:0}, DOWN:{x:0,y:1}
};
const DIRS = [DIR.LEFT, DIR.UP, DIR.RIGHT, DIR.DOWN];
const opposite = d => {
  if(d === DIR.LEFT) return DIR.RIGHT;
  if(d === DIR.RIGHT) return DIR.LEFT;
  if(d === DIR.UP) return DIR.DOWN;
  if(d === DIR.DOWN) return DIR.UP;
  return DIR.NONE;
};
const COLORS = ['#ff0000', '#00ffff', '#ff80ff', '#ff8000'];
const FRIGHT_MS = 8000, DEATH_MS = 1000, CLEAR_MS = 2000;
const deg = a => a * Math.PI / 180;
const mDist = (c1,r1,c2,r2) => Math.abs(c1 - c2) + Math.abs(r1 - r2);

// -------- エンティティクラス --------
class Entity {
  constructor(c, r, s) {
    this.col = c; this.row = r;
    this.x = c * CELL; this.y = r * CELL;
    this.speed = s; this.dir = DIR.NONE;
  }
  atCenter() { return this.x % CELL === 0 && this.y % CELL === 0; }
  canMove(d) {
    if (d === DIR.NONE) return false;
    const nc = this.col + d.x, nr = this.row + d.y;
    return map[nr] && map[nr][nc] !== 1;
  }
  step(px) {
    for (let i = 0; i < px; i++) {
      const nx = this.x + this.dir.x;
      const ny = this.y + this.dir.y;
      const nc = Math.floor((nx + CELL/2) / CELL);
      const nr = Math.floor((ny + CELL/2) / CELL);
      if (map[nr] && map[nr][nc] !== 1) {
        this.x = nx; this.y = ny;
        if (this.atCenter()) { this.col = nc; this.row = nr; }
      } else {
        this.dir = DIR.NONE;
        break;
      }
    }
  }
  tunnel() {
    if (this.x < -CELL) { this.x = W - CELL; this.col = COLS - 1; }
    if (this.x >= W) { this.x = 0; this.col = 0; }
  }
}

// -------- パックマン --------
class Pacman extends Entity {
  constructor(c, r) {
    super(c, r, 2);
    this.nextDir = DIR.NONE;
    this.lastDir = DIR.RIGHT;
    this.dead = false;
    this.deathStart = 0;
  }
  update() {
    if (this.dead) return;
    if (this.atCenter()) {
      if (this.canMove(this.nextDir)) this.dir = this.nextDir;
      if (!this.canMove(this.dir)) this.dir = DIR.NONE;
    }
    this.step(this.speed);
    this.tunnel();
    if (this.dir !== DIR.NONE) this.lastDir = this.dir;
  }
  draw() {
    ctx.save();
    ctx.translate(this.x + CELL/2, this.y + CELL/2);
    let rot = 0;
    const d = this.dir !== DIR.NONE ? this.dir : this.lastDir;
    if (d === DIR.LEFT) rot = Math.PI;
    else if (d === DIR.UP) rot = -Math.PI/2;
    else if (d === DIR.DOWN) rot = Math.PI/2;
    if (gameState === 'dying') rot = -Math.PI/2;
    ctx.rotate(rot);
    let open;
    if (gameState === 'dying') {
      open = deg(180) * Math.min(1, (Date.now()-this.deathStart)/DEATH_MS);
    } else if (this.dir === DIR.NONE) {
      open = deg(45);
    } else {
      const t = Date.now() / 60;
      open = ((Math.sin(t)+1)/2)*(deg(45)-deg(10))+deg(10);
    }
    ctx.fillStyle = '#ff0';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, CELL/2, open, 2*Math.PI - open);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
}

// -------- ゴースト --------
class Ghost extends Entity {
  constructor(c, r, col) {
    super(c, r, 1);
    this.baseColor = col;
    this.home = { c, r };
    this.state = 'normal';
    this.dir = DIRS[Math.floor(Math.random()*4)];
  }
  frightened() { this.state = 'fright'; this.speed = 1; }
  normal() { this.state = 'normal'; this.speed = 1; }
  eaten() { this.state = 'eyes'; this.speed = 2; }
  chooseDir() {
    const moves = DIRS.filter(d => this.canMove(d));
    if (!moves.length) {
      this.dir = opposite(this.dir);
      return;
    }
    if (this.state === 'eyes') {
      moves.sort((a,b) => mDist(this.col+a.x,this.row+a.y,this.home.c,this.home.r) -
                          mDist(this.col+b.x,this.row+b.y,this.home.c,this.home.r));
      this.dir = moves[0]; return;
    }
    const dist = mDist(this.col,this.row,pacman.col,pacman.row);
    if (this.state === 'fright') {
      moves.sort((a,b) => mDist(this.col+a.x,this.row+a.y,pacman.col,pacman.row) -
                          mDist(this.col+b.x,this.row+b.y,pacman.col,pacman.row));
      this.dir = moves[moves.length - 1]; return;
    }
    if (dist < 8) {
      moves.sort((a,b) => mDist(this.col+a.x,this.row+a.y,pacman.col,pacman.row) -
                          mDist(this.col+b.x,this.row+b.y,pacman.col,pacman.row));
      this.dir = moves[0];
    } else {
      if (this.canMove(this.dir) && Math.random() < 0.7) return;
      this.dir = moves[Math.floor(Math.random()*moves.length)];
    }
  }
  update() {
    if (gameState !== 'playing' && gameState !== 'fright') return;
    if (this.atCenter()) this.chooseDir();
    if (this.dir === DIR.NONE) this.chooseDir();
    this.step(this.speed);
    this.tunnel();
    if (this.state === 'eyes' && this.col === this.home.c && this.row === this.home.r)
      this.normal();
  }
  draw() {
    if (this.state === 'eyes') { drawEyes(this); return; }
    ctx.save();
    ctx.fillStyle = this.state === 'fright' ? '#0000ff' : this.baseColor;
    ctx.beginPath();
    ctx.arc(this.x+CELL/2,this.y+CELL/2-4,CELL/2,Math.PI,0);
    ctx.rect(this.x,this.y+CELL/2-4,CELL,CELL/2+4);
    ctx.closePath();
    ctx.fill();
    drawEyes(this);
    ctx.restore();
  }
}
function drawEyes(g) {
  ctx.save();
  ctx.translate(g.x+CELL/2, g.y+CELL/2-4);
  const e=4, p=2;
  ctx.fillStyle = '#fff';
  [[-e,0],[e,0]].forEach(([dx,dy]) => {
    ctx.beginPath(); ctx.arc(dx,dy,4,0,Math.PI*2); ctx.fill();
  });
  const px = g.dir.x*p, py = g.dir.y*p;
  ctx.fillStyle = g.state==='fright'?'#fff':'#00f';
  [[-e+px,py],[e+px,py]].forEach(([dx,dy]) => {
    ctx.beginPath(); ctx.arc(dx,dy,2,0,Math.PI*2); ctx.fill();
  });
  ctx.restore();
}

// -------- マップとゲーム進行 --------
// ...省略せずに「generateMaze」「carve」「ensureConnectivity」「init」「update」「draw」などのロジックを続けて記載してください。
// 長いため一部省略しますが、必要であれば全体貼り出します。

</script>
</body>
</html>
